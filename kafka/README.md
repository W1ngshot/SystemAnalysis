# Kafka в мессенджере

## Описание

Данный документ описывает конфигурацию и использование топиков Kafka, применяемых в Notifications микросервисе. 
Notification микросервис отвечает за обработку двух типов уведомлений:

1. **Уведомления о сообщениях пользователей**
2. **Системные уведомления**

Каждый тип уведомлений обрабатывается независимо через отдельные топики Kafka. Это позволяет достичь следующих преимуществ:

- **Масштабируемость**: Логика обработки разделена, что позволяет масштабировать отдельные компоненты в зависимости от нагрузки.
- **Изоляция логики**: Обеспечивается независимая обработка разных типов уведомлений, что упрощает отладку и сопровождение.
- **Надёжная доставка сообщений**: Используются стратегии гарантированной доставки и механизмы обработки ошибок.

## **OutBox Pattern в Messenger Monolith Application**  

### **Реализация в приложении**  
В нашем приложении OutBox Pattern используется для надежной доставки сообщений через Kafka, включая уведомления о новых сообщениях и системных событиях. Это ключевой механизм обеспечения согласованности между внутренними процессами монолита и внешними сервисами.  

#### **Процесс работы OutBox Pattern**  

1. **Создание записи в Outbox**  
   - При выполнении операции, требующей отправки события в Kafka, событие сначала транзакционно сохраняется в таблицу `Outbox`.  
   - Каждая запись содержит:  
     - **ID** — уникальный идентификатор события (тип `uuid`).  
     - **Тип события (`event_type`)** — строка, указывающая на тип события, например, `UserRegistered` или `MessageSent`.  
     - **Тело события (`payload`)** — данные события в формате JSON.  
     - **Время добавления (`added_at`)** — временная метка, фиксирующая момент записи события.  
     - **Статус обработки (`processed`)** — булево значение, определяющее, было ли событие обработано (`true` или `false`).  
     - **Время обработки (`processed_at`)** — временная метка, указывающая, когда событие было успешно обработано.  
     - **Количество повторных попыток (`retry_count`)** — число неудачных попыток обработки события.  

2. **Обработка таблицы Outbox**  
   - Фоновый процесс (`OutboxProcessor`) регулярно сканирует таблицу на наличие необработанных записей (`processed = false`).  
   - Для каждой найденной записи:  
     - Сериализуются данные из поля `payload`.  
     - Сообщение публикуется в Kafka в указанный топик, связанный с типом события (`event_type`).  
     - Если публикация успешна:  
       - Поле `processed` обновляется на `true`.  
       - Поле `processed_at` заполняется текущей временной меткой.  
     - В случае ошибки:  
       - Увеличивается значение `retry_count`.  
       - Сообщение остается необработанным для последующих попыток.  

3. **Публикация в Kafka**  
   - Используется библиотека `Confluent.Kafka` для публикации событий.  
   - Для каждого события определяется ключ партиционирования (например, ID пользователя), чтобы сообщения, связанные с одной сущностью, направлялись в одну и ту же партицию.  
   - Топик Kafka определяется на основании типа события (`event_type`).  

4. **Повторные попытки обработки**  
   - Записи с высоким значением `retry_count` обрабатываются с использованием механизма экспоненциальной задержки (backoff).  
   - Если превышен лимит повторных попыток, запись может быть перемещена в отдельное хранилище для дальнейшего анализа или ручной обработки.  

#### **Интеграция с Kafka**  
- **Producer Configuration**: Настройка Producer включает управление задержками, количеством повторных попыток и обработкой ошибок.  
- **Partition Key**: Использование Partition Key для равномерного распределения нагрузки по партициям.  
- **Аудит**: Все ошибки записываются в лог-файл для последующего анализа.  

---

## Общий Обзор Топиков

### 1. `send-message-notification-topic-v1`

- **Назначение:** Обрабатывает уведомления, связанные с пользовательскими сообщениями. Топик используется для уведомления пользователей о новых сообщениях, которые они получили в приложении.

- **Продюсер:** Монолит мессенджера публикует события в этот топик при отправке пользователем сообщения другому пользователю.

- **Консьюмер:** Сервис Уведомлений обрабатывает сообщения из этого топика и доставляет уведомления адресатам через `WebSockets` или `Push Notification Service`.

- **Семантика гарантии:** **At least once**. Каждое уведомление гарантированно будет доставлено консьюмеру как минимум один раз. Для избежания дублирования уведомлений реализована логика обработки дубликатов на стороне консьюмера.

- **Стратегия партиционирования:**
  - Партиционирование по `conversation_id`, чтобы все уведомления для одной переписки обрабатывались последовательно. Это исключает возможность появления рассинхронизации между уведомлениями из одной переписки.

- **Формат Ключа:**
  - `conversation_id` (строка): Уникальный идентификатор переписки. Это обеспечивает точность маршрутизации.

- **Формат Значения:** JSON-объект, содержащий:
  ```json
  {
    "event_type": "message_sent",
    "payload": {
      "conversation_id": "c41a5237-80bd-46f8-9bbc-5e1da47d9db3",
      "message_id": "4ffb2f35-9b4e-41d0-9227-795cd5f40f3b",
      "sender_id": "7b8f2d26-29f4-4e1b-bec8-374eb961e7b3",
      "receiver_ids": [
        "5894a085-5bb0-48d4-aa47-be01c9e22574",
        "d74c25f4-3dc5-4ac7-b4ed-c1fcb26753de"
      ],
      "message_text": "text",
      "sent_at": "2025-01-24T12:00:00+00:00",
      "pictures": [
        {
          "picture_id": "1841ff3e-667a-4640-b3e1-d4cb4ef8bebf",
          "resigned_url": "https://example.com/resigned/some-generated-minio-url1.jpg"
        },
        {
          "picture_id": "8a0f18f1-b5b3-493b-955e-f41539425f53",
          "resigned_url": "https://files.messenger.com/some-generated-minio-url2.jpg"
        }
      ]
    }
  }
  ```
- **Доставка уведомлений:**
  - **Пользователи онлайн:**
    - Для пользователей, находящихся в сети, уведомления доставляются через WebSocket-соединение с использованием SignalR Hubs. Это обеспечивает стабильную связь с клиентами, гибкость системы и оптимизацию ресурсов.
    - WebSocket-соединение проверяет состояние сессии пользователя и позволяет мгновенно отправлять уведомления без задержек.
  - **Пользователи оффлайн:**
    - Для пользователей, которые не в сети, push-уведомления доставляются через сервис Push Notification Service. Push-уведомления минимизируют нагрузку на систему, сохраняя при этом важность своевременной доставки сообщений.
  - **Безопасность доставки:**
    - Пользователи подключаются к защищенным SignalR хабам через Auth Handler, интегрированный с Keycloak, для управления аутентификацией и авторизацией. Это предотвращает отправку уведомлений неавторизованным пользователям.

### Преимущества `send-message-notification-topic-v1`

- **Высокая производительность:** Использование партиционирования обеспечивает возможность обработки тысяч уведомлений в секунду.
- **Идемпотентность:** Логика обработки дубликатов исключает появление лишних уведомлений у пользователей.
- **Масштабируемость:** Увеличение количества партиций позволяет обрабатывать большее число пользователей одновременно..

### 2. `system-notifications-topic-v1`

- **Назначение:** Обрабатывает системные уведомления, такие как создание чатов, объявления об изменении информации о чате и другие уведомления, связанные с функциональностью приложения.

- **Продюсер:** Монолит мессенджера публикует события в этот топик при необходимости отправки системного уведомления.

- **Консьюмер:** Notifications микросервис обрабатывает сообщения из этого топика и доставляет их указанным пользователям.

- **Семантика гарантии:** **At least once**. Каждое уведомление гарантированно будет доставлено консьюмеру как минимум один раз. Логика обработки дубликатов реализована на стороне консьюмера.

- **Стратегия партиционирования:**
  - Один партишен или партиционирование по `conversation_id`.

- **Формат Ключа:**
  - `conversation_id` (строка): Определяет тип переписки, к которой относятся уведомления.

- **Формат Значения:** JSON-объект, содержащий:
  ```json
  {
    "event_type": "channel_info_updated",
    "payload": {
      "conversation_id": "c41a5237-80bd-46f8-9bbc-5e1da47d9db3",
      "message_id": "4ffb2f35-9b4e-41d0-9227-795cd5f40f3b",
      "sender_id": "7b8f2d26-29f4-4e1b-bec8-374eb961e7b3",
      "receiver_ids": [
        "5894a085-5bb0-48d4-aa47-be01c9e22574",
        "d74c25f4-3dc5-4ac7-b4ed-c1fcb26753de"
      ],
      "message_text": "text",
      "updated_fields": [
        {
          "field": "title",
          "oldValue": "old title",
          "newValue": "new title"
        },
        {
          "field": "description",
          "oldValue": "description",
          "newValue": "description"
        }
      ],
      "sent_at": "2025-01-24T12:00:00+00:00",
    }
  }
  ```

### Преимущества `system-notifications-topic-v1`

- **Масштабируемость:** Добавление партиций упрощает обработку большого объёма системных сообщений.

## Хранилище для Управления Топиками

Работу топиков регулирует **Notification Redis Storage**, который выполняет следующие функции:

- **Хранение метаданных:** Метаданные уведомлений, такие как статус доставки, сохраняются для анализа и отладки.

- **Идемпотентность:** Состояние уведомлений отслеживается для предотвращения повторной доставки одного и того же сообщения.

- **Мониторинг и аналитика:** Хранилище предоставляет информацию для анализа статистики доставки уведомлений.

## Группы Консьюмеров Kafka

### Группа Консьюмеров для Уведомлений Пользователей

- **Название Группы:** `user-notifications-consumer-group-v1`
- **Описание:** Обрабатывает события из `send-message-notification-topic-v1`. Каждый экземпляр консьюмера отвечает за обработку уведомлений для определённых переписок.

### Группа Консьюмеров для Системных Уведомлений

- **Название Группы:** `system-notifications-consumer-group-v1`
- **Описание:** Обрабатывает события из `system-notifications-topic-v1`. Экземпляры консьюмеров могут обрабатывать системные уведомления параллельно в зависимости от стратегии партиционирования.

## Семантика "At Least Once"

Kafka гарантирует, что сообщения будут доставлены консьюмерам как минимум один раз. Чтобы обеспечить идемпотентность:

- **Дедупликация:** Консьюмеры реализуют логику дедупликации с использованием уникальных идентификаторов (`message_id`).
- **Безопасные транзакции:** Операции вызова `Push Notification Service` корректно обрабатывают повторные попытки и дубли.

## Основная причина выбора Kafka

Kafka предоставляет высокую производительность и удобные механизмы масштабирования, что очень полезно в рамках мессенджера так как:
- Есть большое количество одновременных пользователей и сообщений.
- Необходима мгновенная доставка уведомлений.
- Есть много однотипных сообщений, где можно использовать batch запросы.